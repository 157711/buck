#!/bin/bash

# Exit on error.
set -e

# $BUCK_BIN_DIRECTORY is the directory that hosts this script. Solution taken from:
# http://stackoverflow.com/questions/59895/can-a-bash-script-tell-what-directory-its-stored-in
SOURCE="${BASH_SOURCE[0]}"
DIR="$( dirname "$SOURCE" )"
while [ -h "$SOURCE" ]
do 
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
  DIR="$( cd -P "$( dirname "$SOURCE"  )" && pwd )"
done
DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
BUCK_BIN_DIRECTORY=$DIR

# Set environment and update buck if required.
# TODO(user): refactor buck_common in to functions that can be called
source "${BUCK_BIN_DIRECTORY}/buck_common"

function killBuckdIfRunning()
{
  # Kill any existing buckd process.
  if [ $BUCKD_RUNNING -eq 0 ]; then
    echo "Killing existing buckd process"
    BUCK_PID=$(cat $BUCKD_PID_FILE)
    kill $BUCK_PID &> /dev/null || true
    WAIT_COUNT=1
    echo "Waiting for existing buckd process to exit"
    while [ $(ps -p $BUCK_PID &> /dev/null; echo $? || true) -eq 0 ];
      do sleep 0.1
      WAIT_COUNT=$((WAIT_COUNT + 1))
      if [ $WAIT_COUNT -gt 100 ]; then
        echo "Could not kill existing buckd process after 10 seconds!"
        exit 1
      fi
    done
  fi
}

# Parse flags.
for arg in "$@"
do
case $arg in
  --help)
  echo "Specify --kill to kill buckd."
  exit 0
  ;;

  --kill)
  killBuckdIfRunning
  exit 0
  ;;
esac
done

# Use watchman if available.
if command -v watchman &> /dev/null; then
    echo "Using watchman."
    BUCK_JAVA_ARGS="$BUCK_JAVA_ARGS -Dbuck.buckd_watcher=Watchman"
    watchman watch $PROJECT_ROOT &> /dev/null
else
    echo "Watchman not found, please install when using buckd."
    echo "See https://github.com/facebook/watchman for details."
    echo "(brew install --HEAD watchman on OS X)"
    # Bail if watchman isn't installed as we know java's
    # FileSystemWatcher will take too long to process events.
    exit 0
fi

killBuckdIfRunning

# Create .buckd directory if required.
mkdir -p "$BUCKD_DIR" &> /dev/null || true

# Run buckd. Use SoftRefLRUPolicyMSPerMB for immediate GC of javac output.
# Set timeout to 30s (longer than the biggest GC pause seen for a 2GB heap)
# and GC target to 15s. This means that the GC has to miss its target by 100%
# or many 500ms heartbeats must be missed before a client disconnection occurs.
# Specify port 0 to allow Nailgun to find an available port, then parse the
# port number out of the first log entry.
BUCKD_CLIENT_TIMEOUT_MILLIS=30000
GC_MAX_PAUSE_TARGET=15000
java \
$BUCK_JAVA_ARGS \
-XX:MaxGCPauseMillis=${GC_MAX_PAUSE_TARGET} \
-XX:SoftRefLRUPolicyMSPerMB=0 \
-classpath \
${BUCK_JAVA_CLASSPATH} \
com.martiansoftware.nailgun.NGServer \
localhost:0 $BUCKD_CLIENT_TIMEOUT_MILLIS &> \
$BUCKD_LOG_FILE &
echo $! > "$BUCKD_PID_FILE"
# Block until we read the port number from the buckd log file.
sed -n '1 s/.*port \([0-9]*\)\.$/\1/;p;q' > $BUCKD_PORT_FILE \
<(tail -n +1 -f $BUCKD_LOG_FILE)
