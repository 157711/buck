#!/usr/bin/env python

import xml.etree.ElementTree as ElementTree
import sys

# This parses buck-out/gen/jacoco/code-coverage/index.html after
# `buck test --all --code-coverage --code-coverage-format xml --no-results-cache`
# has been run.
PATH_TO_CODE_COVERAGE_XML = 'buck-out/gen/jacoco/code-coverage/coverage.xml'

# If the code coverage for the project drops below this threshold,
# fail the build. This is designed to far enough below our current
# standards (80% coverage) that this should be possible to sustain
# given the inevitable ebb and flow of the code coverage level.
CODE_COVERAGE_BY_LINE_GOAL = 78


def is_covered_package_name(package_name):
    """We exclude third-party code and code generated by javacc."""
    if not package_name.startswith('com/facebook/buck/'):
        return False
    if package_name == 'com/facebook/buck/apple/xcode/xcconfig':
        # TODO: This package has a mix of handwritten and autogenerated code.
        # This script should be updated to include the handwritten code in the
        # metrics.
        return False
    return True


def calculate_code_coverage():
    root = ElementTree.parse(PATH_TO_CODE_COVERAGE_XML)

    line_coverage = []
    max_package_name = 0

    total_line_covered = 0
    total_line = 0

    for element in root.findall('.//package'):
        package_name = element.attrib['name']
        if not is_covered_package_name(package_name):
            continue

        max_package_name = max(max_package_name, len(package_name))
        for counter in element.findall('./counter'):
            counter_type = counter.attrib.get('type')
            missed = int(counter.attrib.get('missed'))
            covered = int(counter.attrib.get('covered'))

            percentage = round(100 * covered / float(missed + covered), 2)
            if counter_type == 'LINE':
                total_line_covered += covered
                total_line += missed + covered
                line_coverage.append({'package_name': package_name, 'percentage': percentage})

    def pair_compare(p1, p2):
        # High percentage should be listed first.
        diff1 = cmp(p2['percentage'], p1['percentage'])
        if diff1:
            return diff1
        # Ties are broken by lexicographic comparison.
        return cmp(p1['package_name'], p2['package_name'])

    def label_with_padding(label):
        return label + ' ' * (max_package_name - len(label)) + ' '

    def print_separator():
        print '-' * (max_package_name + 7)

    # Print header.
    print label_with_padding('PACKAGE') + 'LINE'
    print_separator()

    # Print rows sorted by line coverage then package name.
    line_coverage.sort(cmp=pair_compare)
    for item in line_coverage:
        package_name = item['package_name']
        padding = ' ' * (max_package_name - len(package_name))
        percentage = item['percentage']
        color = '\033[92m' if percentage >= CODE_COVERAGE_BY_LINE_GOAL else '\033[93m'
        print '%s%s%s%%\033[0m' % (color, label_with_padding(package_name), percentage)

    # Print aggregate numbers.
    total_line_percentage = round(100 * total_line_covered / float(total_line), 2)
    color = '\033[92m' if total_line_percentage >= CODE_COVERAGE_BY_LINE_GOAL else '\033[93m'
    print_separator()
    print '%s%s%s%%\033[0m' % (color, label_with_padding('TOTAL'), total_line_percentage)

    return total_line_percentage


def is_code_coverage_met():
    coverage = calculate_code_coverage()
    return coverage >= CODE_COVERAGE_BY_LINE_GOAL


def main():
    """Exits with 0 or 1 depending on whether the code coverage goal is met."""
    if not is_code_coverage_met():
        sys.exit(1)


if __name__ == '__main__':
    main()
